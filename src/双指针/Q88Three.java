package 双指针;

/**
 * 88. 合并两个有序数组
 * 给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。
 * 请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。
 * 注意：最终，合并后数组不应由函数返回，而是存储在数组nums1中。为了应对这种情况，
 *      nums1的初始长度为m+n，其中前m个元素表示应合并的元素，后n个元素为0，应忽略。nums2的长度为 n 。
 *      这个方法是逆向双指针，因为nums1中多余的位置在数组的最后面，而数组又是从小到大排序过的，所以可以
 *      取出大元素来放到最后面，因为最后面的元素都没有赋值，默认是0
 */

public class Q88Three {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
//        下面的p1和p2是用来遍历两个数组的指针（就是数组下标）所以需要在数组元素长度上减一
        int p1 = m - 1,p2 = n-1;
//        从后向前遍历nums1数组，tail就是最后一个元素的下标
        int tail = m + n - 1;
//        定义一个临时变量来储存遍历到的元素
        int cur;
//        遍历完两个数组
//        下面的操作中只要取出一个数组元素后，都要把数组下标+1来方便下一次的遍历
        while (p1 >= 0 || p2 >= 0){
//            如果此时p1=-1则代表nums1数组已经遍历完，此时只需要遍历nums2数组
            if (p1 == -1){
                cur = nums2[p2--];
//            如果此时p2=-1则代表nums2数组已经遍历完，此时只需要遍历nums1数组
            }else if (p2 == -1) {
                cur = nums1[p1--];
//            执行下面两个循环的条件是两个数组都没有遍历完
//            目的是为了取出两个数组中更大的那个元素
            }else if (nums1[p1] > nums2[p2]){
                cur = nums1[p1--];
            }else {
                cur = nums2[p2--];
            }
//            根据题目要求nums1中后部分都是0所以可以直接把取出的那个较大的数直接放进去
            nums1[tail--] = cur;
        }
    }
}
