package KMP;

/**
 * 28. 实现 strStr()
 * 实现 strStr() 函数。
 * 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
 * 这里用的是KMP算法，KMP算法是一个快速查找匹配串的算法，它的作用其实就是本题问题：如何快速在「原字符串」中找到「匹配字符串」。
 */

public class Q28Two {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
//        取出两个字符串的长度
        int n = haystack.length(),m = needle.length();
//        原串和匹配串前面都加空格，使其下标从 1 开始
//        目的是让 j 下标从 0 开始，省去 j 从 -1 开始的麻烦。
//        因为匹配串第一个比较是j+1，j的位置是哨兵位置0，每次next的值都是j的值，加一个哨兵这样j开始在哨兵节点0，当遍历
//        匹配串第一个字符时下标就是1，前缀就是0了。
//        其实加不加都可以，只是后面比较方式不同，这里加哨兵就可以让前缀取到下标为0的的前缀了，然后每次比较都是j+1的位置进行比较，
//        不匹配的时候其前缀就是next数组中j下标位置元素的值。就不需要找前缀时进行-1操作了。因为每次比较的都是j+1，前缀就是j
        haystack=" "+haystack;
        needle=" "+needle;
//        把两个字符串变成两个字符数组进行遍历，这样可以不用charAt方法
        char[] hay = haystack.toCharArray();
        char[] need = needle.toCharArray();
//        构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）因为前面匹配串加了一个哨兵
        int[] next = new int[m+1];
//        构造过程i = 2，j = 0开始，i小于等于匹配串长度，因为字符串前有哨兵（下标为0）i为后缀指针为2，j是前缀指针
//        i前缀指针永远比j后缀指针大，这样才能保证一个是前缀一个是后缀
        for (int i = 2,j = 0;i<=m;i++){
//            为什么下面都是j+1而不直接设置j=1？
//            因为最前面加了一个哨兵（空格）这个不需要比较所以j第一次匹配时需要加1
//        匹配不成功：当一直匹配不上时会一直将j前缀指针左移直到j=o退出循环，这里是while，j是公共前缀的长度，除非找到了j后面那个下标得值等于i的值，否则就
//            一直向前找，直到有一个下标位置的等于i，为什么这么做，因为可以保留相等的前缀，减少查找次数
            while (j > 0 && need[i] != need[j+1])
//                因为上面比较的是j+1的下标位置不匹配，所以j前缀指针此时只需要回到next数组中j下标位置的值即可
//                且j在next数组对应的下标一直比匹配串的下标小1，因为next[哨兵]=0。然后匹配串第一个字符对应的next下标位置也是0
                j = next[j];
//        匹配成功：就当前位置也属于最长相等个前缀的一部分了，就把前缀j+1再赋值到next数组中
            if (need[i] == need[j+1]) j++;
//          更新 next[i]，结束本次循环，i++,next数组只有最后也就是这一次操作全部完成才会进行更新，
            next[i] = j;
        }
//        匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
//        因为最前面有一个哨兵，所以需要从1开始
        for (int i = 1,j = 0; i<=n; i++){
            // 匹配不成功 j = next(j)
//            kmp 最重要的就是最长相等前缀，所以代码中有关比较相等的地方都是用的j+1，因为前缀是不包括自身的（j+1），所以j就是前缀
//            如果不匹配了，那么while次数越少，保留的最长相等前缀就越长，记住，j=next[j]但是比较的是j+1，也就是比较相等前缀的后面一个字符
//            每次比较如果不匹配就返回next数组中上次的最长相等前缀,如果next当前j位置是0就跳到0,next数组值是上面得出的,只与匹配串有关
//            j=next[j]为的是找到有没有当前匹配串字符的最长前缀.可以减少匹配次数
            while (j > 0 && hay[i] != need[j+1]) j = next[j];
            // 匹配成功的话，先让 j++，结束本次循环后 i++
            if (hay[i] == need[j+1]) j++;
            // 整一段匹配成功，直接返回下标
            if (j == m) return i-m;
        }
        return -1;
    }
}
