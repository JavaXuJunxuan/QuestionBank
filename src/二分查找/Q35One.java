package 二分查找;

/**
 * 35. 搜索插入位置
 * 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
 * 请必须使用时间复杂度为 O(log n) 的算法。
 * 这道题可能有两种临界情况：
 * 1.数组缩减到最后时有元素等于目标值，此时两种方法都可以得到答案
 * 2.当最后时数组中没有元素等于目标值时：要返回这个元素应该插入的下标，那么这个下标就是遍历到最后的右坐标
 * 对应的两种情况：
 * 向下取整时，条件为中间值小于目标值此时left= mid+1正好取到答案。向下取整为左节点应该+1得到答案
 * 但是向上取整时，目标值一定是小于右节点的元素的，此时会right=mid-1而失去答案。向上取整为右节点应该直接取出节点
 *
 */

public class Q35One {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length;
        while (left < right){
//            这里的mid是向下进行取整
            int mid = (right - left)/2 + left;
//            这里的判断条件是中间值小于目标值，此时表示中间值左边的都不可能为答案直接舍去把左边界提过来
            if (nums[mid] < target){
                left = mid + 1;
//                如果中间值大于等于目标值，则中间值可能为目标值，但是中间值右边的一定不可能舍去
            }else {
                right = mid;
            }
        }
        return left;
    }
}
